### 编程范式

​		现在很多的文章和演讲都在谈架构，很少有人在会谈及编程范式，然而这些基础和本质的话题，却时非常重要的。



​		一方面，我发现一些语言争论上，有很多人对编程语言认识其实并不深刻；另一方面，通过编程语言的范式，我们不但可以知道整个编程语言的发展史，而且还能提高自己的编程技能，进而写出更好的代码。



​	

##### 编程范式

​		编程语言发展到今天，出现了很多不同代码编写方式，但是殊途同归，那就是如何写出更为统用，更具有可重用性的代码或者模块。



###### C语言

​		几乎可以看到，所有的语言都是以C语言为基础来拓展的，不管C++，java C#，Go，python，php，perl，js，lua，还是shell



​		自C语言问世40多年来，影响了太多太多的编程语言，到现在还一直被广泛使用，不得不佩服它的生命力，但是我们要清楚的知道，大多数的C like编程语言其实都是在改善C语言带来的问题。

那么C有什么特性？

​			1· C语言时一个静态弱类型语言，**在使用变量时需要生命变量类型**，但是类型间可以有隐式的转换；

​			2·不同的变量类型可以用结构体struct组合在一起，以此来声明数据类型

​			3·C可以用typedef**关键字来定义类型别名**，以此来达到变量类型的抽象

​			4·C式一个有结构化程序设计，具有变量作用域以及递归功能的过程式语言

​			5·C传递参数一般是以值传递，也可以传递指针

​			6· 通过指针，C可以容易的针对内存进行低级控制，**然而这加大的编程的复杂度**

​			7·编译预处理让C的编译更具有弹性，**比如跨平台**



​		其实C的这些特性，可以让程序员在微观层面写除非常精确的编程操作，也可以在底层和系统细节上非常自由，灵活和精准的控制代码

​		然而在代码组织和功能编程上，C语言的上述特性，没有那么美好

​		举个变量交换的栗子：

~~~C
void swap(int* x, int* y)
{
    int tmp = *x;
    *x = *y;
    *y = tmp
}
~~~

为啥要传指针？

​	如果不用指针的话，那么变成传值，即函数的形参是调用实参的一个拷贝，函数里面对形参的修改无法影响实参的结果。为了要达到调用完函数后，实参内容交换，必须要把实参的地址传递进来，也就是传指针。这样在函数里面做交换，实际变量的值也被交换了

​	然而这个函数最大问题就是它只能给int值用，这个世界上还有很多中数据类型，包括double和饥饿float等，这就是静态语言最糟糕的一个问题



##### 数据类型与显示世界类比

​	数据类型就好像螺帽一样，有多中接口方式：平口的，十字的，六角的等，而螺丝刀就像是函数，或者是用来操作这些螺丝的算法或者代码。我们发现，这些不同类型的螺帽（数据类型），需要我们为之适配不同的螺丝刀！



​	而且它们还有不同的尺寸【**尺寸就是代表他是单字节的还是多字节的**，比如int，long，浮点数float，double】，这样复杂度一下就提高了，最终导致电工【程序员】工作的时候就需要带很多的工具，心好累。

​	这就是类型为变成带来的问题，需要结局这个问题我们还需要来看下现实世界——手柄只有一个，但是螺丝刀的接口【一字，梅花等】有很多种，花样百出——不过本质就是：我们通过使用一种更为通用的方式，**用另外话说就是抽象和隔离**，让复杂的世界变得简单一点



​	然而要做到抽象，对于C语言这样的类型语言来说，第一个要拿出来讲的就是抽象类型——**泛型编程**

​	另外我们注意到，在编程世界里，对于C语言来说，类型还可以做转换。编译器会使用以且方式来做类型转换，因为类型转换有时又可以让我们在编程的时候更方便一些，也让相近的类型可以做到一点点的泛型。

​	然而，对于C的类型转换，是会出很多问题的。比如说，传给我一个数组，这个数组本来是double型的，或者是long型64位的，但是如果把数组类型强转称int，那么就会出现很多问题，**因为这回导致程序遍历数组的步长不一样**

​	比如一个double a[10]的数组，a[2]意味着a + sizeof(double) * 2。如果你把a强转成int，那么a[2]就意味着a + sizeof（int）* 2.我们知道sizeof（double）是8，而sizeof（int）是4，于是访问到了不同的地址和内存空间，这就会导致程序出现严重的错误。



#### C语言的泛型

###### 一个泛型的示例 - swap 函数

​		看下C是如何实现泛型的。**C的类型泛型基本上来说就是使用void \*关键字 或者是使用宏定义**

~~~C
void swap(void* x, void* y, size_t size)
{
    char tmp[size];
    memcpy(tmp,y,size);
    memcpy(y,x,size);
    memcpy(x,tmp,size);
}
~~~

​	上面这个函数几乎完全改变了int版的函数的实现方式，这个实现方式有三个重点：

​	· **函数接口增加了一个size参数**。为什么要这么干？因为一旦用了void* 后，**类型就会被抽象掉**，编译器不能通过类型得到类型的尺寸了，所以我们需要手动加上一个类型长度的标识。

​	·**函数的实现种使用了memcpy（）函数**。为什么要这么干？**还是因为被抽象掉了**，所以不能用赋值表达式了，很可能传进来的参数类型还是一个结构体，不过为了要交换这些复杂类型的值，我们只能使用内存复制的方法了

​	·**函数的实现种使用了一个tmp[size]数组**。这就是减缓数据时需要用的buffer，会用buffer来组临时的空间存储



​	于是新增的size参数，使用memcpy内存拷贝以及一个buffer，这增加了编程的复杂度，而这就是C语言的类型抽象带来的复杂度的提升

​	在提升复杂度的同时我们还发现问题，比如，我们想交换两个字符串数组，类型时char*，那么，我们的swap（）函数的x和y参数是不是要用void**了？？而这样一来，就接口就没法定义了。



**其他更为复杂的，以后补充【对C并不太了解】**

### 小结

这里如果说  程序 = 算法 + 数据，C语言会有这样几个问题：

 	1. 一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C只能使用void* 或者宏替换的方式，这两种方式导致了类型过于宽松，并带来其他的很多问题
 	2. 适配数据类型，需要C在泛型中加入一个类型的size，这是因为我们识别不了被泛型后的数据类型，而C语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。
 	3. 算法其实是在操作数据结构，而数据则时放到数据结构中的，所以真正的泛型除了数据类型外，还要适配数据结构。最后这个事情导致泛型算法复杂急剧上升，比如容器内存的分配和回收，不同的数据体可能有非常不一样的内存分配和释放模型；再比如，对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到深拷贝，还是浅拷贝。
 	4. 最后，再实现泛型算法的时候，你会发现自己在纠结那些东西应该抛给调用者处理，哪些又是可以封装起来的。而如何平衡和选择，并没有定论，也不好解决。
 	5. 理想情况下，算法应该是和数据结构以及类型无关的，各种特殊的数据类型理应做好自己分内的工作，算法只关心一个标准的实现。而对于泛型的抽象，我们需要回答的问题是，如果我们的数据类型符合通用算法，那么对数据类型的最小需求又是什么呢？——c++通过类的方式来解决，**类里面会又构造函数和析构函数标识这个类的分配和释放，还有它的拷贝构造函数，表示了对内存的复制，还有重载操作符，象我们要去比较大于等于不等于**
 	6. 自己理解下——回调函数是为了实现更加抽象的泛型问题，实现了业务逻辑和数据操作的分离
 	7. **类型的本质：类型是对内存的一种抽象。不同的类型，会有不同的内存布局和内存分配策略。不同的类型，有不同的操作。所以对于特定的类型，也有特定的要一组操作**
 	8. **泛型编程的本质：我理解的本质就是，屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多的关注算法的结构，而不是算法中处理不同的数据类型**