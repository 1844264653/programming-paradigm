### 函数式编程——泛函编程

​	对于函数式编程来说，它只关心**定义输入数据和输出数据相关的关系，数学表达式里面其实式在做一种映射mapping，输入的数据和输出的数据关系是什么样的，是用函数来定义的**

​	函数式编程有以下特点：

· **stateless**：【无国籍？】函数不维护任何状态。函数式匾额很难过的核心精神式stateless，简而言之**就是他不能存在状态**，打个比方，你给我数据我处理完扔出来，里面的数据式不变的。

**immutable**：输入数据式不能动的，动了输入数据就有危险，所以要返回新的数据集。

##### 	优势

​	· 没有状态就没有伤害

​	·并行执行无伤害

​	·Copy-Paste重构代码无伤害

​	·函数的执行没有顺序上的问题

还带来了一些好处：

​	·惰性求值： 这需要编译器支持，表达式不在它被绑定到变量之后就立即求职，而是在该值被取用的时候求值。

​	·确定性

##### 	劣势

​	·数据复制比较严重



#### 函数式编程用到的技术

·first class function  头等函数：这个技术可以让你的函数就像变量一样来使用。也就是说，你的函数可以像变量一样被创建，修改，并当成变量一样传递，返回，或是在函数中嵌套函数

·tail recursion optimization 尾递归优化：递归太深了，stack受不了的，并且会导致性能大幅度下降。因此，我们使用尾递归优化技术——每次递归时都会重用stack，这样能够提升性能。当然，这需要语言或者编译器的支持，**python就不支持**

·map & reduce ： 这个技术就不用说了，泛函编程最常见的技术就是对一个集合做map和reduce操作

·pipeline 管道： 这个技术的意思是，将函数实例成一个一个的action，然后将一组action放到一个数组或者是列表中，再把数据传给这个action list，数据就像一个pipeling一样顺序的被各个函数所操作，最终得到我们想要的结果。

·recursion 递归 ： 递归最大的好处就是简化单吗，它可以把一个复杂的问题用很简单的代码描述出来。**注意：递归的精髓是描述问题，而这正是函数式编程的精髓**

·**curring 柯里化**： 将一个函数的多个参数分解成多个函数，然后将函数多层封装起来，每层函数都返回一个函数去接收下一个参数。在c++中，这很想STL中的bind1st和bind2nd

·higer order function 高阶函数 ：所谓高阶函数就是函数当参数，把传入的函数做一个封装，然后返回这个封装函数。现象上就是函数传进传出，就像面向对象对象漫天飞一样。**这个技术用来做decorator很不错**



总结：

​		 把函数当作变量来使用【柯里化】，**关注描述问题而不是怎么实现，这样可以让代码更易读**

​		因为函数返回里面这个函数，所以函数关注的式表达式，关注的是描述这个问题，而不是怎么实现这个事情



#### 函数式编程的思维方式

前面提到，函数式编程关注的式 describe what to do，rather than how to do it。于是我们把以前的过程式的编程叫做imperative programming - 指令式编程，而把函数式编程范式交叫做declarative programming - 声明式编程

#### 函数式语言三件套

函数式语言有三件套：Map Reduce和Filter

#### 函数式pipeline模式

pipeline管道借鉴于Unix shell的管道操作——把若干个命令串起来，前面命令的输出称为后面命令的输入，如此完成一个流式计算。

~~~markdown
管道绝对是一个伟大的发明，它的设计哲学就是KISS - 让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装会变得更为简单和直观。这个设计理念影响非常深远，包括今天的Web Service， 云计算，以及大数据的流式计算等
~~~

比如我们的shell 命令

~~~linux
ps auwwx|awk '{print $2}'|sort -n|xargs echo
~~~

上面的命令就是查看一个用户执行的进程列表，列出来以后取第二列，第二列是它的进程ID，排序，再把它显示出来。

抽象成函数的样子

~~~linux
xargs(echo,sort(n,awk('print $2',ps(auwwx))) )
~~~

我们也可以把函数放进数组里面，然后顺序执行

~~~linux
pids = for_each(result, [ps_auwwx,awk_ps,sort_n,xargs_echo])
~~~

如果把这些函数比作微服务，**那么管道这个事情是在干什么呢**，其实就是在做服务的编排。像Unix这些经典的技术上的实现或者理论，往往是可以反映到分布式架构上的，所以，一般来说，一个好的分布式架构师，通常都是对传统微观上的经典技术有非常深刻的认识，因为这些东西在方法论上都是相通的

